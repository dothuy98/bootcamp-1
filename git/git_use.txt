git 基礎 : 
自分で作成したファイルをcommitし、pushする。
（準備）
そのためにまずはその作業を表すわかりやすいブランチ名を作成し、（例 : git branch make_log)
git add ファイル名を行い、インデックスという領域に追加したファイル、もしくは修正したファイルを追加する。
その際、git status を行うとuntracked filesからChanges not staged for commitというグループに移動することから確認できる。
（commit）
git statusで本当にインデックスに追加されたすべてのファイルの内容をコミットしていいのかを確認する。
もし、あるファイルはやっぱりコミットしたくないという場合は 
git reset 該当のファイル名 HEAD
で戻すことができる。最後にHEADを指定するのはどこまで伸ばすかを指定しているためで、ここでは最新のコミットの状態までもどすという意味になる。
もしくは、
git reset <file_name>
でも同じことが行える。これは引数をファイル名のみにすると、ステージングから該当のファイルを取り除けという意味にコマンドを解釈するためである。
また、すべてコミットしない場合は
git reset . HEAD
を行う。
ファイルの変更内容自体も戻す場合は --hard というオプションをつける。
コミットを取り消す場合に --soft を使用する。

確認後、大丈夫だと判断できた場合には、
git commit -m "メッセージ"
でコミットを行う。-m というオプションでこのコミットをなぜ行ったかをわかりやすく記述する。
また、-m オプションを付けない場合は専用のエディタ画面に飛び、そこでメッセージを記述する。
（push)
git commitまではローカルレポジトリのブランチで変更を反映させるためのコマンドで、リモートレポジトリには影響がない。
git pushではローカルレポジトリの変更をリモートレポジトリに反映させるための処理を行う。
また、手順を踏みリモートレポジトリへの反映に近づくほど、取り消すための処理も増えるためgit status、git diffでの確認をその都度行うようにすべきと考える。
pushは
git push リモートレポジトリ名 ブランチ名
で行うことができる。
リモートレポジトポリは git remote -v で参照でき、
ブランチ名は git branch -vvで参上できる。
このとき、ブランチ名をmain(master)などにしてしまうとプルリクエストをgithubから行えないため注意が必要。
これはmain(master)のgithub上での役割が問題がない状態のコードのみを取りまとめるという役割があるためであると考えられる。
PRは変更を行い、問題がないかチェックするために行い、問題がない場合にmain(master)にマージを行う。
したがってmain(master)でpushした場合、PRしてもマージのしようがないため行えないと考えられる。

git pushを取り消す場合は
git revert commit_id
で行う。revertコマンドの場合は履歴（ログ）にpushを取り消したことが残る。
また、resetコマンドでもpushを取り消せるが、強制的にpushする必要があるため非推奨。
強制的なpushを使う場面を調べてみると基本的に個人での開発のみでherokuでデプロイを行う場合などで見られた。
したがって、複数人での開発では絶対に使うべきではない。
具体的にはgit push --force を行うと、強制pushした人のコミットでレポジトリがもつ変更履歴の親子関係を無視して上書きするような形でpushを行うため、他の人のローカルレポジトリとリモートレポジトリの親子関係が不整合になるためエラーが起きる。


git 差分 : 
git diff HEAD : を行うと作業ディレクトリ（現状）と最終コミットを比較できる。
（実行例）$ git diff HEAD
diff --git a/git/git_command_memo.txt b/git/git_command_memo.txt
index 0fb166e..5de6b89 100644
--- a/git/git_command_memo.txt
+++ b/git/git_command_memo.txt
@@ -68,3 +68,5 @@ git pull :
 git merge --abortでmergeを取り消し、git reset --hard HEADで直前のコミットまで戻すことができる。
 （オプション）
 git pull -v : 詳しいメッセージを表示する。
+
+test : 新しいテキスト

というようになり+で始まる行（緑色）が追加された内容を表す。
また、-で始まる行（赤色）の場合作業ディレクトリ（現状）にない行を表す。
HEADは今いるブランチの最新のコミットという意味で、作業ディレクトリ（現状）と最新コミットの差分を出力する。また、別のブランチのコミットは比較されない。
別ブランチの場合はgit cheakout ブランチ名 > git diff HEADで同様に差分を確認できる。

また、注意点として新しく作成したファイルは比較対象に入らない。
新しく作成したファイルを比較対象にする場合は
git add -N ファイル名
を行う。このコマンドはgit diffの対象になるがコミットの対象にならないようにファイルを指定できる。
したがってそのファイルをインデックスに追加してコミットさせたい場合は別途、 git add する必要がある。


.gitignoreについて : 
gitのレポジトリにおいて意図的に追跡対象から外したいファイルを設定するためのファイル。
また、gitignoreを更新したらcommitしないと反映されない。
すでに追跡対象になったファイルを無視したい場合には、
git rm --cache ファイル名
を実行した後、該当ファイルを.gitgnoreに記述し、commitすれば無視できる。
また、 git rm において--cacheというオプションをつけない場合、ファイルの存在も削除し、インデックスからも削除される。
linuxコマンドのrmではなくgit rm を使用するのはインデックス存在を無視しないためだと考える。
レポジトリに複数存在することも可能で、有効範囲はその.gitgnoreがあるカレントディレクトリを含む、それよりしたのディレクトリを対象にする。
（フォーマット）
# で始まる行はコメントアウトされる。
空白は認識されないので区切り文字として使える。
* は/（スラッシュ）以外の0文字以上の文字を指定するワイルドカードとして使用できる。
? は/（スラッシュ）以外の1文字をワイルドカードとして指定する。
** はすべてのディレクトリを指定する。
/（スラッシュ）を使用せず、ファイル名のみを行に記述した場合もディレクトリの位置に関係なくファイル名が一致するものを無視する。
! で始める場合はそのパターンを無視しない。
（実用例）
https://github.com/github/gitignore
というURLで.gitgnoreのテンプレートが存在した。
共通点として、設定ファイルやツールなどをインストールする際にローカル環境独自に作られるMakefileなどを記述する。

