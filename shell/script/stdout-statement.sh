#!/bin/bash

# 標準入力として実行された値がコマンドの場合、その実行内容をファイルにリダイレクトし、それ以外では標準入力をリダイレクトする。

echo "ファイルに記述したい内容を入力してください。コマンドとして実行できる場合は実行結果をファイルに記述します。(enterで終了）"
read order
# デフォルトの区切り文字がタブ・スペースの為 、区切り文字がスペース、タブの場合は(${value//区切り文字/区切り文字を置換する文字})と書かなくてもよい。
# 入力内容のコマンド部分のみを抽出するために配列に分割する。
command=(${order})

# if文では[]を使用しないと終了ステータスが0の場合、trueと判断し、それ以外をfalseと判断する。
# ガード節を使用し記述をするため、!を付けてnot条件にした。

# 本来typeは引数がシェルでどのように実行されるかを確認するコマンド。
# ここでは引数がコマンドと認識されるかどうかを、if文で終了ステータスを見て判断するために使った。
if ! type "${command[0]}" > /dev/null 2>&1; then
    # > /dev/null で標準出力を/dev/nullというからファイルに出力するという意味になり、標準出力が捨てられる。
    # 2>&1 で標準エラー出力の出力先を標準出力に設定されているパスに設定するという意味で、空ファイル(/dev/null)が設定されているため捨てられる。
    # 1> /dev/null 2> /dev/null でも同じ意味（ 1> : 標準出力のこと。 > と同じ意味 ）
    # ※/dev/null以外は2回リダイレクトしているため先に出力されるstderrは消えるため使えない。
    echo "終了ステータス : $?"
    # !(not条件)はif文の中で実行したコマンドの終了ステータス自体を反転させる(0 -> 1, 0以外 -> 1という終了ステータスになる）
    echo "終了ステータスが0であるため、入力内容はコマンドとして実行できない"
    echo $order > stdout.txt
    # > でファイルに上書き、ファイルが存在しない場合は新しく作成後、記述。
    # >> の場合は追加出力となり、ファイルの最下部へ標準出力が追加される。ファイルがない場合は > と同様に作成後、記述。
    echo "stdout.txtに入力内容を標準出力としてリダイレクトした"
    exit 0
fi

echo "標準入力はコマンドとして認識された。"
eval $order > stdout.txt
echo "stdout.txtに入力内容をコマンドとして実行し、標準出力としてリダイレクトした"
